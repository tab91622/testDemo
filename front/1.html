<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link rel="stylesheet" href="/iconfont/iconfont.css"/><link rel="stylesheet" href="/css/valine.css"/><script src="//unpkg.com/valine/dist/Valine.min.js"></script><title>文章详情</title><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/15b92494358f552df174.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15b92494358f552df174.css"/><link rel="preload" href="/_next/static/css/052ae0a44094706a10c2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/052ae0a44094706a10c2.css"/><link rel="preload" href="/_next/static/css/f0082a2b33ba635f4dd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f0082a2b33ba635f4dd9.css"/><link rel="preload" href="/_next/static/chunks/main-d5ecf0b3951669ce080c.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-488dc228921f1fdbc0e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1b5fae6dde8a26be77ac.js" as="script"/><link rel="preload" href="/_next/static/chunks/346fcacd.acdc88755e55ded238c8.js" as="script"/><link rel="preload" href="/_next/static/chunks/5b942159a78d3c3cc608ccd4b77e51e0983cab29.ed4d58faabcf26e54f52.js" as="script"/><link rel="preload" href="/_next/static/chunks/08b74a7a597619e1b87151c58acc0528a78ab6f6.c061d003d0886c32baa8.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-176d4174c88ce65d60a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/front/%5Bid%5D-d60ad66e03ab4249afa4.js" as="script"/></head><body><div id="__next"><div class="Header_nav__p_kME"><a class="Header_item__3KWCo" href="/">博客首页</a><a class="Header_item__3KWCo" href="/front">文章列表</a><a class="Header_item__3KWCo" href="/front/logs">更新日志</a><a class="Header_item__3KWCo" href="/front/about">关于</a></div><div class="main"><div class="FrontRoute_container__zQhnm"><div class="FrontRoute_markdown__3G6E8"><h1>getServerSideProps</h1><p>页面中<code>export</code>一个<code>async</code>的getServerSideProps方法，next就会<strong>在每次请求时候在服务端调用这个方法。</strong></p><p><strong>方法只会在服务端运行，每次请求都运行一边getServerSideProps方法</strong></p><p>如果页面通过浏览器端Link组件导航而来，Next会向服务端发一个请求，然后在服务端运行getServerSideProps方法，然后返回JSON到浏览器。</p><blockquote><p>getServerSideProps方法主要是<strong>升级</strong>了9.3之前的<code>getInitialProps</code>方法</p></blockquote><p>9.3之前的getInitialProps方法有一个很大的缺陷是在<strong>浏览器中req和res对象会是undefined</strong>。也就是使用它的页面，如果是浏览器渲染你需要在组件内再显示地请求一次。开发体验不太好。 如果没有特殊问题，建议使用getServerSideProps替代getInitialProps方法。</p><h1>getStaticProps</h1><p>使用getStaticProps方法<strong>在build阶段返回页面所需的数据</strong>。</p><p>如果是动态路由的页面，使用getStaticPaths方法来返回所有的路由参数，以及是否需要回落机制。</p><h1>getStaticPaths</h1><p>处理动态路由,
1. 该函数返回<code>{paths, fallback}</code>
2. 服务端构建 渲染的时候,会根据<code>paths</code>(一般是一个数组)的内容执行<code>getStaticProps</code>并传递相关参数
3. 从而根据数据构建静态页面</p><h2>fallback</h2><p>false : 没什么用</p><p>true : 会多执行一次<code>getStaticProps</code>,生成<code>[id].html</code></p><ul><li>当一开始没有在之前的静态页面(根据动态路由生成的)找到目标路由时,会先返回<code>[id].html</code></li><li>然后服务端马上执行一次<code>getStaticProps</code>,根据新的<code>id</code>在渲染一次该组件,返回html</li></ul></div><hr/><div><div class="FrontRoute_aside__3gFP5"><div class="FrontRouteAside_container__1pfKw"><a class="FrontRouteAside_link__4IF8A FrontRouteAside_right__286L6" href="/front/2">下一篇：服务端仓库共享问题</a></div></div><div class="FrontRoute_comments__2cMR7"><div><h2>发表评论</h2><div class="Comment_wrapper__184xV1"></div><h2 id="/front/1" class="leancloud_visitors" data-flag-title="getServerSideProps方法"><i class="iconfont icon-liulan"></i>  <i class="leancloud-visitors-count"></i></h2></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"1","title":"getServerSideProps方法","prev":null,"next":{"id":2,"title":"服务端仓库共享问题"},"md":{"data":"# getServerSideProps\r\n页面中```export```一个```async```的getServerSideProps方法，next就会**在每次请求时候在服务端调用这个方法。**\r\n\r\n**方法只会在服务端运行，每次请求都运行一边getServerSideProps方法**\r\n\r\n\r\n如果页面通过浏览器端Link组件导航而来，Next会向服务端发一个请求，然后在服务端运行getServerSideProps方法，然后返回JSON到浏览器。\r\n\r\n\r\n\u003e getServerSideProps方法主要是**升级**了9.3之前的```getInitialProps```方法\r\n\r\n9.3之前的getInitialProps方法有一个很大的缺陷是在**浏览器中req和res对象会是undefined**。也就是使用它的页面，如果是浏览器渲染你需要在组件内再显示地请求一次。开发体验不太好。 如果没有特殊问题，建议使用getServerSideProps替代getInitialProps方法。\r\n\r\n\r\n# getStaticProps\r\n使用getStaticProps方法**在build阶段返回页面所需的数据**。\r\n\r\n如果是动态路由的页面，使用getStaticPaths方法来返回所有的路由参数，以及是否需要回落机制。\r\n\r\n\r\n# getStaticPaths\r\n处理动态路由,\r\n1. 该函数返回```{paths, fallback}```\r\n2. 服务端构建 渲染的时候,会根据```paths```(一般是一个数组)的内容执行```getStaticProps```并传递相关参数\r\n3. 从而根据数据构建静态页面\r\n\r\n## fallback\r\nfalse : 没什么用\r\n\r\ntrue : 会多执行一次```getStaticProps```,生成```[id].html```\r\n- 当一开始没有在之前的静态页面(根据动态路由生成的)找到目标路由时,会先返回```[id].html```\r\n- 然后服务端马上执行一次```getStaticProps```,根据新的```id```在渲染一次该组件,返回html\r\n"}},"__N_SSG":true},"page":"/front/[id]","query":{"id":"1"},"buildId":"jB9Y7kPKJdexBq0JD9Xuy","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-c0664c850fd807bc92c2.js"></script><script src="/_next/static/chunks/main-d5ecf0b3951669ce080c.js" async=""></script><script src="/_next/static/chunks/webpack-488dc228921f1fdbc0e7.js" async=""></script><script src="/_next/static/chunks/framework.1b5fae6dde8a26be77ac.js" async=""></script><script src="/_next/static/chunks/346fcacd.acdc88755e55ded238c8.js" async=""></script><script src="/_next/static/chunks/5b942159a78d3c3cc608ccd4b77e51e0983cab29.ed4d58faabcf26e54f52.js" async=""></script><script src="/_next/static/chunks/08b74a7a597619e1b87151c58acc0528a78ab6f6.c061d003d0886c32baa8.js" async=""></script><script src="/_next/static/chunks/pages/_app-176d4174c88ce65d60a8.js" async=""></script><script src="/_next/static/chunks/pages/front/%5Bid%5D-d60ad66e03ab4249afa4.js" async=""></script><script src="/_next/static/jB9Y7kPKJdexBq0JD9Xuy/_buildManifest.js" async=""></script><script src="/_next/static/jB9Y7kPKJdexBq0JD9Xuy/_ssgManifest.js" async=""></script></body></html>