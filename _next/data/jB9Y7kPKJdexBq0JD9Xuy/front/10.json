{"pageProps":{"id":"10","title":"TypeScript 泛型","prev":{"id":9,"title":"TypeScript 装饰器"},"next":null,"md":{"data":"# 泛型\r\n有时书写某个函数时,会丢失一些类型信息(多个位置的类型应该保持一致或有关联的信息)\r\n\r\n泛型: 是指附属于函数 类 接口 类型别名之上的别名\r\n\r\n## 使用\r\n\r\n### 函数泛型\r\n```函数名<泛型符号>(){ }``` \r\n* **传递的是一个数字数组,可以根据参数推断出泛型 T 也是数字类型**\r\n```js\r\nfunction take<T>(arr: T[], n: number): T[] {\r\n  return n>= arr.length ? arr : arr.splice(n)\r\n}\r\n// 传递的是一个数字数组,可以根据参数推断出泛型\r\ntake([1, 3, 4, 3, 5], 3)\r\n```\r\n\r\n### 类泛型\r\n```类名<泛型符号>{ }```\r\n\r\n\r\n### 类型别名的泛型\r\n**将 别名名称 和 ```<泛型符号>``` 作为一个整体使用**\r\n\r\n**一般用于设置回调函数的泛型**\r\n\r\n```js\r\n// 不能确定 n 到底是数字还是字符串 对象等其他类型\r\n// 使用泛型统一类型信息\r\ntype callback<T> = (n: T, i?: number) => boolean\r\n\r\nfunction myFilter<T>(arr: T[], cb: callback<T>): T[] {\r\n  let newArr: T[] = []\r\n  newArr = arr.filter(n => cb(n))\r\n\r\n  return newArr\r\n}\r\n\r\nmyFilter([1, 2, 3, 5, 6, 9], n => n % 2 !== 0)\r\n```\r\n\r\n## 细节\r\n* 很多时候,TS 可以**智能地根据传递的参数,推导出泛型的具体类型** \r\n\r\n* 如果无法完成推导,并且又没有传递具体的类型,**默认为空对象**\r\n\r\n* 泛型可以设置默认值\r\n\r\n## 泛型约束\r\n主要用于约束某一个对象泛型的子类型\r\n\r\n* 该泛型是一个对象,同时必须具有 name 属性\r\n```js\r\ninterface hasName {\r\n  name: string\r\n}\r\n\r\n/**\r\n * @param obj 将一个对象中的name 属性的每个单词首字母大写\r\n */\r\nfunction nameToUpper<T extends hasName>(obj: T): T {\r\n  obj.name = obj.name.split(' ')\r\n    .map(s => s.charAt(0).toUpperCase() + s.slice(1))\r\n    .join(' ')\r\n\r\n  return obj\r\n}\r\n```\r\n\r\n## 多泛型\r\n依赖多种类型\r\n\r\n```js\r\nfunction merg<T, K>(arr1: T[], arr2: K[]): (T | K)[] {\r\n  if (arr1.length !== arr2.length) {\r\n    throw new Error('数组长度不相等')\r\n  } else {\r\n    const newArr: (T | K)[] = []\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      newArr.push(arr1[i], arr2[i])\r\n    }\r\n    return newArr\r\n  }\r\n}\r\n\r\nconsole.log('merg([1,2,3]: ', merg([1, 2, 3], ['a', 'b', 'c']));\r\n```"}},"__N_SSG":true}