{"pageProps":{"id":"7","title":"深入了解 setState","prev":{"id":6,"title":"React 生命周期"},"next":{"id":8,"title":"node 生命周期"},"md":{"data":"* 组件为了能够维护自身的状态,设置了```state```\r\n* 为了能够让React跟踪到状态的变化,规定只能通过```setState```更新状态\r\n\r\n## 可能异步\r\n\r\nsetState 的调用方式相当于 **Object.assign(*之前的state,新的state*)**\r\n\r\n然而,其实 setState 改变数据这个行为,有时候**可能是异步**的,也就是说,如果要立即获取改变后的状态,可能做不到\r\n\r\n如下的代码的大致过程:\r\n1. state 中声明了一个 n\r\n2. html 中的 button 注册了一个点击事件\r\n3. 点击后,让 n + 1\r\n4. 立即打印 n\r\n\r\n**无论点击多少次,打印的始终是上一次 n 的值(不同步)**\r\n```js\r\nexport default class Test extends Component {\r\n  state = {\r\n    n: 0\r\n  }\r\n  handleClick=()=>{\r\n    this.setState({\r\n      n:this.state.n + 1\r\n    })\r\n\r\n    console.log(this.state.n)  // 上面调用了 setState 后,立即打印 n : 依然等于 0\r\n  }\r\n\r\n  render() {\r\n    console.log('render')\r\n    return (\r\n      <div>\r\n        <h1>{this.state.n}</h1>\r\n        <button onClick={this.handleClick}>add</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n## 原因推测\r\n问题的根源,因为还没读过源码,暂且讲不清楚\r\n\r\n不过根据下面的代码,可以推测一二:\r\n* 在```constructor```中添加了一定时器\r\n* 通过定时器回调函数改变状态, n + 1\r\n* 立即打印改变后的状态\r\n\r\n这时,**每次都是打印改变后的状态 n(同步)**\r\n\r\n```js\r\nexport default class Test extends Component {\r\n  state = {\r\n    n: 0\r\n  }\r\n\r\n  constructor(props){\r\n    super(props)\r\n    setInterval(()=>{\r\n      this.setState({\r\n        n:this.state.n + 1\r\n      })\r\n\r\n      console.log(this.state.n)\r\n    },1000)\r\n  }\r\n\r\n  render() {\r\n    console.log('render')\r\n    return (\r\n      <div>\r\n        <h1>{this.state.n}</h1>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n两相比较,得出初步结论: **在HTML上使用的处理函数调用的，是异步的;其他都是同步的**\r\n\r\n## 如何立即访问更新后的状态\r\n这里说的只是html处理函数调用的 `setState`(其他的调用方式都是同步改变的)\r\n\r\n### 使用 setState 的第二个参数 \r\nsetState 方法的第二个参数是一个**回调函数**,该函数会在**所有异步改变状态的 setState 执行完之后被调用**\r\n\r\n如下的情况(例子仅仅说明问题,没有实际意义):\r\n```js\r\nexport default class Test extends Component {\r\n  state = {\r\n    n: 0\r\n  }\r\n  handleClick=()=>{\r\n    this.setState({\r\n      n:this.state.n + 1\r\n    },()=>{\r\n      console.log('n: ',this.state.n)\r\n    })\r\n  }\r\n\r\n  render() {\r\n    console.log('render')\r\n    return (\r\n      <div>\r\n        <h1>{this.state.n}</h1>\r\n        <button onClick={this.handleClick}>add</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n回调函数中打印的```this.state.n```是改变后的状态数据\r\n\r\n### setState 直接传递一个函数\r\n当需要**连续改变多次状态**,并且使用多次改变状态之后的值时,如果使用上面的方法会造成嵌套,而且导致组件渲染多次,不太好\r\n\r\n可以给 setState 传递一个函数(同样的,例子仅仅说明问题,没有实际意义):\r\n1. 点击 button 后,连续三次修改状态\r\n2. 函数的**参数** ```cur```是当前状态,**返回值**是一个对象,与之前的状态 ```Object.assign```\r\n3. 点击一次,实现了 n + 3\r\n\r\n```js\r\nexport default class Test extends Component {\r\n  state = {\r\n    n: 0\r\n  }\r\n  handleClick = () => {\r\n    this.setState(cur => ({\r\n      n: cur.n + 1\r\n    }))\r\n    this.setState(cur => ({\r\n      n: cur.n + 1\r\n    }))\r\n    this.setState(cur => ({\r\n      n: cur.n + 1\r\n    }))\r\n  }\r\n\r\n  render() {\r\n    console.log('render')\r\n    return (\r\n      <div>\r\n        <h1>{this.state.n}</h1>\r\n        <button onClick={this.handleClick}>add</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n## 结论\r\n* setState 状态是**不可信任**的,不要使用一般方式立即访问\r\n* **HTML 上的处理函数调用**的,比如: `onClick` `onMouseEnter` `onMouseDown` 等等,都是**异步**;其他方式是同步的\r\n* 可以给 setState **传递第二个参数**,立即获取改变后的状态\r\n* 连续改变状态时,**传递一个函数**,函数参数为当前状态,返回值是将要混合的对象"}},"__N_SSG":true}