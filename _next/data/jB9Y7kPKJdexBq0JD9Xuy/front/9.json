{"pageProps":{"id":"9","title":"TypeScript 装饰器","prev":{"id":8,"title":"node 生命周期"},"next":{"id":10,"title":"TypeScript 泛型"},"md":{"data":"# 装饰器\r\n装饰器可以带来额外的信息量,达到分离关注点的目的\r\n\r\n* 信息的书写位置问题  数据定义和数据的约束信息分开了,验证时很不方便\r\n* 重复代码的问题\r\n\r\n上述两个问题产生的根源: 某些信息,在定义时,能够附加的信息有限\r\n\r\n装饰器的作用:\r\n* 为某些属性 类 参数 方法 提供元数据信息(metadata)\r\n> 元数据: 描述信息的信息\r\n\r\n装饰器在 JS 中的**本质是一个函数(是要参与运行的)**\r\n\r\n## 类装饰器\r\n类的装饰器,可以给类添加额外的信息,**在类创建完之后就会立即执行**  以下是编译后的代码:\r\n\r\n```js\r\nfunction test(target) {\r\n    console.log(target);\r\n}\r\nlet A = class A {\r\n};\r\nA = __decorate([\r\n    test\r\n], A);\r\n```\r\n\r\n要么无返回值,要么只能返回一个类: 新的类会替换掉之前的类;而返回一个函数,会作为之前类的 ```constructor```\r\n\r\n调用装饰器:\r\n* 可以没有参数(默认传递一个类)\r\n    * 注意: 装饰器返回了另外一个类,并且,调用 A 构造出来的,也是另一个类的实例\r\n```js\r\nfunction test(target: new ( ...arg:any[] ) => object) {\r\n  console.log(target === A)   // true\r\n  return class B { }\r\n}\r\n\r\n@test\r\nclass A {\r\n\r\n}\r\n\r\nconst ins = new A()\r\nconsole.log('ins: ', ins);  // B {}\r\n```\r\n\r\n* 也可以有参数\r\n    * 有参数时,先作为普通函数调用;然后返回的类装饰器仍一定要传入 类 参数\r\n```js\r\nfunction d1(str:string){\r\n  console.log('str: ', str);\r\n  return function (target:new ()=>object){\r\n    console.log('d1 decorator')\r\n  }\r\n}\r\n\r\n@d1(\"Jack\")\r\nclass A {}\r\n/* \r\nstr:  Jack\r\nd1 decorator\r\n*/\r\n```\r\n\r\n### 装饰器运行顺序\r\n1. 首先是函数直接调用,然后将装饰器函数返回\r\n2. 多个装饰器,会按添加顺序 ***从后往前***\r\n\r\n```js\r\nfunction d1(){\r\n  console.log(\"d1\")\r\n  return function (target:new ()=>object){\r\n    console.log('d1 decorator')\r\n  }\r\n}\r\n\r\nfunction d2(){\r\n  console.log(\"d2\")\r\n  return function (target:new ()=>object){\r\n    console.log('d2 decorator')\r\n  }\r\n}\r\n\r\n@d1()\r\n@d2()\r\nclass A {}\r\n/* \r\nd1\r\nd2\r\nd2 decorator\r\nd1 decorator\r\n*/\r\n```\r\n\r\n## 成员装饰器\r\n\r\n### 属性\r\n类的成员是属性时的装饰器参数:\r\n* **实例属性**,第一个参数为 **类的原型**;第二个参数为 属性名\r\n* **静态属性**,第一个参数为 **类本身**;第二个参数为 属性名\r\n\r\n```js\r\nfunction d1(target: any, key: string) {\r\n  console.log(target === A.prototype, key)  // true prop1\r\n}\r\n\r\nfunction d2(target: any, key: string) {\r\n  console.log(target === A, key)  // true prop2\r\n}\r\n\r\nclass A {\r\n  @d1\r\n  prop1: string\r\n\r\n  @d2\r\n  static prop2: string\r\n}\r\n\r\nconst a = new A()\r\n```\r\n\r\n### 方法\r\n类的方法装饰器函数传递的前两个参数的情况同上;第三个参数的约束类型为 ```PropertyDescriptor```,即属性配置描述:\r\n```js\r\n{\r\n  value: [Function: method1],\r\n  writable: true,\r\n  enumerable: false,\r\n  configurable: true\r\n}\r\n```\r\n\r\n可以直接通过第三个参数修改方法的属性配置:\r\n\r\n```js\r\n// 相当于将该方法重新赋值 \r\ndescriptor.value = ()=>{\r\n    console.warn('该方法已过期')\r\n  }\r\n```\r\n\r\n\r\n## 参数装饰器\r\n好像只能修饰类的方法的参数\r\n\r\n装饰器参数:\r\n1. 实例方法为 类的原型,静态方法为 类本身\r\n2. 方法名称\r\n3. 被修饰的参数的索引\r\n\r\n```ts\r\nfunction d1(target: any, methodName: string, index: number) {\r\n  console.log(target === User.prototype, methodName, index) // true sayInfo 1\r\n}\r\n\r\nfunction d2(target: any, methodName: string, index: number) {\r\n  console.log(target === User, methodName, index) // true sayHello 1\r\n}\r\n\r\nclass User {\r\n  sayInfo(name: string, @d1 age: number) { }\r\n\r\n  static sayHello(name: string, @d2 age: number) { }\r\n}\r\n\r\nconst u = new User()\r\n```\r\n\r\n### TS 自动注入元数据\r\n安装了 ```reflect-metadata```,且导入了该库,且在某个成员上添加了元数据,并且开启了 ```emitDecoratorMetadata```,那么在编译结果中,会将约束的类型作为元数据加入到相应位置中\r\n\r\n* TS 代码\r\n```js\r\nimport 'reflect-metadata'\r\n\r\nconst metadataKey = Symbol.for('description')\r\n\r\n@Reflect.metadata(metadataKey,'用户')\r\nclass User{\r\n  @Reflect.metadata(metadataKey,'姓名')\r\n  name:string \r\n\r\n  @Reflect.metadata(metadataKey,'年龄')\r\n  age:number\r\n}\r\n\r\nconst u = new User()\r\nu.name = 'Jack'\r\nu.age = 20\r\n```"}},"__N_SSG":true}