{"pageProps":{"id":"8","title":"node 生命周期","prev":{"id":7,"title":"深入了解 setState"},"next":{"id":9,"title":"TypeScript 装饰器"},"md":{"data":"## node 生命周期\r\n循环外两个队列:\r\nnextTick --> promise\r\n\r\n循环内有六个队列:\r\n**timer** --> ... --> ... --> **poll** --> **check** --> ...\r\n\r\n### timer\r\nnode 也有专门计时的线程,会不断查看 setTimeout setInterval 中的回调任务是否应该进入队列\r\n\r\n* 该例子说明,由于其他队列的阻塞和干扰,**定时器的实际回调时间,可能会远远大于设置的回调时间**\r\n\r\n```js\r\nconst fs = require('fs')\r\n\r\nconst start = Date.now()\r\nsetTimeout(() => {\r\n  console.log('setTimeout: ', Date.now() - start) // 512\r\n}, 200)\r\n\r\nfs.readFile('./1.txt', 'utf-8', (err, data) => {\r\n  if (!err) {\r\n    console.log('data: ', data);\r\n    const start = Date.now()\r\n    while (Date.now() - start < 500) { }\r\n  }\r\n})\r\n```\r\n\r\n### poll\r\n轮询\r\n注意: 不是把读取文件这个行为添加到这个队列中(行为时操作系统做的),**只是把读取文件结束 或者用户请求的回调函数添加到该队列中**\r\n\r\n**自己有任务时,先清空自己的,然后等待,循环停留**\r\n\r\n等待其他队列中添加任务,然后恢复循环\r\n\r\n等待很长的时间后,结束时间循环,应用关闭\r\n\r\n### check\r\nsetImmediate 中的任务会被直接扔入该队列\r\n\r\n* 输出的结果不固定\r\n    * 主要是因为系统执行的不确定因素,很可能会因为一些事耽搁进入循环,那么 timer 队列就会直接打印\r\n    * 如果没有事情耽搁,查看 timer 队列的时候,里面还没有任务,会往后查看\r\n```js\r\nsetTimeout(()=>{\r\n  console.log('setTimeout')\r\n},1)\r\n\r\nsetImmediate(()=>{\r\n  console.log('setImmediate')\r\n})\r\n```"}},"__N_SSG":true}